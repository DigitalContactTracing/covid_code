{
    "docs": [
        {
            "location": "/",
            "text": "Digital Proximity Tracing in the COVID-19 Pandemic on Empirical Contact Networks\n\n\n\n\nG. Cencetti +\n - Fondazione Bruno Kessler, Trento, Italy\n\n\nG. Santin +\n - Fondazione Bruno Kessler, Trento, Italy\n\n\nA. Longa\n - Fondazione Bruno Kessler, Trento, Italy, and University of Trento, Trento, Italy\n\n\nE. Pigani\n - Fondazione Bruno Kessler, Trento, Italy\n\n\nA. Barrat\n - Aix Marseille Univ, Universit\u00e9 de Toulon, CNRS, CPT, Turing Center for Living Systems, Marseille, France - Tokyo Tech World Research Hub Initiative (WRHI), Tokyo Institute of Technology, Tokyo, Japan\n\n\nC. Cattuto\n - University of Turin, Turin, Italy - ISI Foundation, Turin, Italy\n\n\nS. Lehmann\n - Technical University of Denmark, Copenhagen, Denmark\n\n\nM. Salath\u00e9\n - \u00c9cole Polytechnique F\u00e9d\u00e9rale de Lausanne (EPFL), Lausanne, Switzerland\n\n\nand \nB. Lepri\n - Fondazione Bruno Kessler, Trento, Italy\n\n\n\n\n+\n These authors contributed equally to this work.\n\nLink to the \npaper\n.\n\nLink to the \ncode\n.",
            "title": "Home"
        },
        {
            "location": "/#digital-proximity-tracing-in-the-covid-19-pandemic-on-empirical-contact-networks",
            "text": "G. Cencetti +  - Fondazione Bruno Kessler, Trento, Italy  G. Santin +  - Fondazione Bruno Kessler, Trento, Italy  A. Longa  - Fondazione Bruno Kessler, Trento, Italy, and University of Trento, Trento, Italy  E. Pigani  - Fondazione Bruno Kessler, Trento, Italy  A. Barrat  - Aix Marseille Univ, Universit\u00e9 de Toulon, CNRS, CPT, Turing Center for Living Systems, Marseille, France - Tokyo Tech World Research Hub Initiative (WRHI), Tokyo Institute of Technology, Tokyo, Japan  C. Cattuto  - University of Turin, Turin, Italy - ISI Foundation, Turin, Italy  S. Lehmann  - Technical University of Denmark, Copenhagen, Denmark  M. Salath\u00e9  - \u00c9cole Polytechnique F\u00e9d\u00e9rale de Lausanne (EPFL), Lausanne, Switzerland  and  B. Lepri  - Fondazione Bruno Kessler, Trento, Italy   +  These authors contributed equally to this work. \nLink to the  paper . \nLink to the  code .",
            "title": "Digital Proximity Tracing in the COVID-19 Pandemic on Empirical Contact Networks"
        },
        {
            "location": "/DigitalContactTracing/",
            "text": "DigitalContactTracing\n\n\nA class that implements digital contact tracing on a real contact network.\n\n\nThe class loads an existing network and simulates the spread of a virus on \nthe network, based on the characteristics of an infectious disease. \nAt the same time, a digital contact tracing policy is implemented to try to\ncontain the spread of the virus by enforcing isolation and quarantine, \ndepending on the policy specifications.\nThe class keeps track of a number of relevant quantities (mainly, tracing \nefficacy and histories of quarantined individuals).  \n\n\nAttributes of the class are listed below:\n\n\n\n\n\n\n\n\nATTRIBUTES\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nI\n\n\ndict\n\n\ndetails of infected people\n\n\n\n\n\n\ninfected\n\n\nlist\n\n\ninfected people\n\n\n\n\n\n\nisolated\n\n\nlist\n\n\nisolated people\n\n\n\n\n\n\nquarantined\n\n\nlist\n\n\nquarantined people\n\n\n\n\n\n\nsymptomatic\n\n\nlist\n\n\nsymptomatic people\n\n\n\n\n\n\neT\n\n\nlist\n\n\ntracing effectivity, per time instant\n\n\n\n\n\n\ntemporal_gap\n\n\nfloat\n\n\ntemporal gap between static networks\n\n\n\n\n\n\nmemory_contacts\n\n\nint\n\n\ntracing memory\n\n\n\n\n\n\nmax_time_quar\n\n\nfloat\n\n\nquarantine duration\n\n\n\n\n\n\ncontacts\n\n\nlist\n\n\ncontacts of each node\n\n\n\n\n\n\nsym_t\n\n\nlist\n\n\nsymptomatic people, full history\n\n\n\n\n\n\niso_t\n\n\nlist\n\n\nisolated people, full history\n\n\n\n\n\n\nact_inf_t\n\n\nlist\n\n\ninfected people, full history\n\n\n\n\n\n\nq_t\n\n\nlist\n\n\nnumber of quarantined, full history\n\n\n\n\n\n\nq_t_i\n\n\nlist\n\n\nnumber of wrongly quarantined, full history\n\n\n\n\n\n\nQ_list\n\n\nlist\n\n\nquarantined, full history\n\n\n\n\n\n\nQi_lis\n\n\nlist\n\n\nwrongly quarantined, full history\n\n\n\n\n\n\nsympt\n\n\nfloat\n\n\nwrongly fraction of symptomatic individuals\n\n\n\n\n\n\ntest\n\n\nfloat\n\n\nwrongly  fraction of asymptomatics who are detected via random testing\n\n\n\n\n\n\neps_I\n\n\nfloat\n\n\nwrongly  isolation effectivity\n\n\n\n\n\n\nfilter_rssi\n\n\nfloat\n\n\nwrongly RSSI threshold of the digital tracing policy\n\n\n\n\n\n\nfilter_duration\n\n\nfloat\n\n\nwrongly duration threshold of the digital tracing policy\n\n\n\n\n\n\ngraphs\n\n\nlist\n\n\nsnapshots of the temporal graph\n\n\n\n\n\n\nbeta_t\n\n\nfloat\n\n\nparameter defining the infectiousness probability\n\n\n\n\n\n\nuse_rssi\n\n\nbool\n\n\nflag to decide if the simulation is on a SocioPattern dataset\n\n\n\n\n\n\nY_i_nodes\n\n\nlist\n\n\ninitially infected nodes\n\n\n\n\n\n\nNC_nodes\n\n\nlist\n\n\nnodes who do not use the app\n\n\n\n\n\n\n\n\nMethods of the class are listed below:\n\n\n\n\n\n\n\n\nMETHODS\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nspread_infection\n(graph, node, new_infected, current_time)\n\n\nPropagates the infection from an infected node to its neighbors.\n\n\n\n\n\n\nenforce_policy\n(current_time,node,in_quarantine)\n\n\nUpdates the state of symptomatic people.\n\n\n\n\n\n\ninizialize_contacts\n(graph)\n\n\nInitialize the contacts from the temporal graph.\n\n\n\n\n\n\ninizialize_infected_time0\n()\n\n\nInitialize the status of the initial infected people.\n\n\n\n\n\n\npolicy\n(graph, node)\n\n\nImplements a policy on a node in a graph.\n\n\n\n\n\n\nsimulate\n()\n\n\nRuns the simulation.\n\n\n\n\n\n\nupdate_contacts\n(graph)\n\n\nUpdates the list of traced contacts.\n\n\n\n\n\n\nupdate_quarantined\n(current_time)\n\n\nUpdate the list of quarantined people.\n\n\n\n\n\n\nupdate_infected\n( current_time, graph, new_infected)\n\n\nUpdates the state of the infected nodes.\n\n\n\n\n\n\ncheck_quarantined\n( current_time)\n\n\nCheck the status of quarantined nodes.\n\n\n\n\n\n\n\n\nspread_infection\n\n\nspread_infection(graph, node, new_infected, current_time)\n\n\n\nPropagates the infection from an infected node to its neighbors.\n\n\nThe method loops over the neighbors of an infected node and selectively \npropagates the infection (i.e., add the neighbors to the list of \ninfected nodes). \nTo decide if the infection is propagated or not, the method checks the \nduration and proximity of a contact and the infection probability \nbeta_data.  \n\n\nINPUT\n  \n\n\n\n\ngraph - networkx.classes.graph.Graph snapshots of the temporal graph\n\n\nnode - the id of the node under consideration\n\n\nnew_infected - list of pearson newely infected \n\n\ncurrent_time - float the absolute time since the beginning of the simulation\n\n\n\n\nenforce_policy\n\n\nenforce_policy(current_time,node,in_quarantine)\n\n\n\nUpdate the state of a symptomatic node and quarantine its contacts.\n\n\nThe method updates the state of a node which is found infected, i.e., \nit is isolated and its contacts are quarantined.\nFirst, the node is added to the list of isolated nodes and removed from\nthe list of infected (if it is not quarantined) or from the list of \nquarantined (if it is quarantined).\nSecond, if the node is adopting the app, the list of its past contacts \nwhich were 'at risk' is processed and each node is quarantined.\nThird, the efficacy of this tracing step is computed and appended to \nthe global list self.eTt. \n\n\nINPUT\n  \n\n\n\n\nnode - the id of the node under consideration\n\n\nin_quarantine - boolean flag that specify if the pearson is already qurantained and he/she shows simptoms \n\n\ncurrent_time - float the absolute time since the beginning of the simulation  \n\n\n\n\ninizialize_contacts\n\n\ninizialize_contacts(graph)\n\n\n\nInitialize the contacts from the temporal graph.  \n\n\nThe method creates a list where the element at position idx is \nthe list of contacts of the node idx. Each of these lists is initally empty. \n\n\nINPUT\n  \n\n\n\n\ngraph - networkx.classes.graph.Graph snapshots of the temporal graph\n\n\n\n\ninizialize_infected_time0\n\n\ninizialize_infected_time0(graph)\n\n\n\nInitialize the status of the initial infected people. \n\n\nThe method adds the people contained in self.Y_i_nodes to the list I, and defines their infectiousness properties.  \n\n\npolicy\n\n\npolicy(graph, node)\n\n\n\nImplements a policy on a node in a graph.\n\n\nThe method gets the neighbors of the node, and for each neighbor it applies the policy to decide if it is 'at risk' or not. \n\n\nINPUT\n  \n\n\n\n\ngraph - networkx.classes.graph.Graph snapshots of the temporal graph\n\n\nnode - the id of the node under consideration\n\n\n\n\nsimulate\n\n\nsimulate()\n\n\n\nRun the simulation.\n\n\nThe method runs the simulation on the temporal network.\n\n\nOUTPUT\n\n\n\n\neT: list  tracing effectivity, per time instant\n\n\nsym_t: list  symptomatic people, full history\n\n\niso_t: list  isolated people, full history\n\n\nact_inf_t: list infected people, full history\n\n\nq_t: list number of quarantined, full history\n\n\nq_t_i: list number of wrongly quarantined, full history\n\n\nQ_nb: list number of distict elements in self.Q_list\n\n\nQi_nb: list number of distinct elements in self.Qi_list\n\n\nI: dict details of infected people\n\n\n\n\nupdate_contacts\n\n\nupdate_contacts(current_time)\n\n\n\nUpdate the list of quarantined people\n\n\nINPUT\n  \n\n\n\n\ncurrent_time - the absolute time since the beginning of the simulation  \n\n\n\n\nupdate_infected\n\n\nupdate_infected( current_time, graph, new_infected)\n\n\n\nUpdates the state of the infected nodes.\n\n\nThe method updates the state of each infected node by advancing in time\nits information and by checking if it has become symptomatic.\nMoreover, an infected node may be isolated according to the isolation \nefficiency: If it is not isolated, it spread the infection to its \nneighbors; If it is isolated, the tracing policy is enforced on its \ncontacts.\n\n\nINPUT\n  \n\n\n\n\ncurrent_time - float the absolute time since the beginning of the simulation  \n\n\ngraph - networkx.classes.graph.Graph snapshots of the temporal graph\n\n\nnew_infected - list of pearson newely infected \n\n\n\n\ncheck_quarantined\n\n\ncheck_quarantined(current_time)\n\n\n\nCheck the status of quarantined nodes.\n\n\nThe method checks if a nodes becomes symptomatic while in quarantine, and in this case the tracing policy is enforced on its contacts.\n\n\nINPUT\n  \n\n\n\n\ncurrent_time - float the absolute time since the beginning of the simulation  \n\n\n\n\nUTILITIES\n\n\nstore_real_time\n\n\nstore_real_time(res,PARAMETERS,filter_rssi,filter_duration,eps_I)\n\n\n\nStore the results of the simulation at the end of each single iteration.\nIf the file does not exists, it create the file, otherwise it append the current results to the file.\n\n\nINPUT\n  \n\n\n\n\nres - list that contains the output of the simulation\n\n\nPARAMETERS - dict containing all the parameters of the simulation (se the examples Digital-Contact-Tracing on SocioPattern.ipynb and Digital-Contact-Tracing on DTU.ipynb)\n\n\nfilter_rssi - float  wrongly RSSI threshold of the digital tracing policy \n\n\nfilter_duration - float  wrongly duration threshold of the digital tracing policy\n\n\neps_I - float wrongly  isolation effectivity\n\n\n\n\nload_results\n\n\nload_results(path,file,eps_I,filter_rssi,filter_duration)\n\n\n\nLoad stored results\n\n\nINPUT\n  \n\n\n\n\npath - string representing the path in which results are stored\n\n\nfile - string specifing the file to load. One of the follow:\n\n\nq_t\n  number of quarantined\n\n\nq_t_i\n number of wrongly quarantined\n\n\nQ_list\n list  of quarantined\n\n\nQi_lis\n list of wrongly quarantined\n\n\nI\n dict  with details of infected people \n\n\nsym_t\n list of symptomatic people\n\n\niso_t\n list of isolated people\n\n\nact_inf_t\n list of infected people\n\n\n\n\n\n\neps_I - float wrongly  isolation effectivity\n\n\nfilter_rssi - float  wrongly RSSI threshold of the digital tracing policy \n\n\nfilter_duration - float  wrongly duration threshold of the digital tracing policy\n\n\n\n\nOUTPUT\n\n\n\n\nAn array containing the loaded results.",
            "title": "DigitalContactTracing"
        },
        {
            "location": "/DigitalContactTracing/#digitalcontacttracing",
            "text": "A class that implements digital contact tracing on a real contact network.  The class loads an existing network and simulates the spread of a virus on \nthe network, based on the characteristics of an infectious disease. \nAt the same time, a digital contact tracing policy is implemented to try to\ncontain the spread of the virus by enforcing isolation and quarantine, \ndepending on the policy specifications.\nThe class keeps track of a number of relevant quantities (mainly, tracing \nefficacy and histories of quarantined individuals).    Attributes of the class are listed below:     ATTRIBUTES  Type  Description      I  dict  details of infected people    infected  list  infected people    isolated  list  isolated people    quarantined  list  quarantined people    symptomatic  list  symptomatic people    eT  list  tracing effectivity, per time instant    temporal_gap  float  temporal gap between static networks    memory_contacts  int  tracing memory    max_time_quar  float  quarantine duration    contacts  list  contacts of each node    sym_t  list  symptomatic people, full history    iso_t  list  isolated people, full history    act_inf_t  list  infected people, full history    q_t  list  number of quarantined, full history    q_t_i  list  number of wrongly quarantined, full history    Q_list  list  quarantined, full history    Qi_lis  list  wrongly quarantined, full history    sympt  float  wrongly fraction of symptomatic individuals    test  float  wrongly  fraction of asymptomatics who are detected via random testing    eps_I  float  wrongly  isolation effectivity    filter_rssi  float  wrongly RSSI threshold of the digital tracing policy    filter_duration  float  wrongly duration threshold of the digital tracing policy    graphs  list  snapshots of the temporal graph    beta_t  float  parameter defining the infectiousness probability    use_rssi  bool  flag to decide if the simulation is on a SocioPattern dataset    Y_i_nodes  list  initially infected nodes    NC_nodes  list  nodes who do not use the app     Methods of the class are listed below:     METHODS  Description      spread_infection (graph, node, new_infected, current_time)  Propagates the infection from an infected node to its neighbors.    enforce_policy (current_time,node,in_quarantine)  Updates the state of symptomatic people.    inizialize_contacts (graph)  Initialize the contacts from the temporal graph.    inizialize_infected_time0 ()  Initialize the status of the initial infected people.    policy (graph, node)  Implements a policy on a node in a graph.    simulate ()  Runs the simulation.    update_contacts (graph)  Updates the list of traced contacts.    update_quarantined (current_time)  Update the list of quarantined people.    update_infected ( current_time, graph, new_infected)  Updates the state of the infected nodes.    check_quarantined ( current_time)  Check the status of quarantined nodes.",
            "title": "DigitalContactTracing"
        },
        {
            "location": "/DigitalContactTracing/#spread_infection",
            "text": "spread_infection(graph, node, new_infected, current_time)  Propagates the infection from an infected node to its neighbors.  The method loops over the neighbors of an infected node and selectively \npropagates the infection (i.e., add the neighbors to the list of \ninfected nodes). \nTo decide if the infection is propagated or not, the method checks the \nduration and proximity of a contact and the infection probability \nbeta_data.    INPUT      graph - networkx.classes.graph.Graph snapshots of the temporal graph  node - the id of the node under consideration  new_infected - list of pearson newely infected   current_time - float the absolute time since the beginning of the simulation",
            "title": "spread_infection"
        },
        {
            "location": "/DigitalContactTracing/#enforce_policy",
            "text": "enforce_policy(current_time,node,in_quarantine)  Update the state of a symptomatic node and quarantine its contacts.  The method updates the state of a node which is found infected, i.e., \nit is isolated and its contacts are quarantined.\nFirst, the node is added to the list of isolated nodes and removed from\nthe list of infected (if it is not quarantined) or from the list of \nquarantined (if it is quarantined).\nSecond, if the node is adopting the app, the list of its past contacts \nwhich were 'at risk' is processed and each node is quarantined.\nThird, the efficacy of this tracing step is computed and appended to \nthe global list self.eTt.   INPUT      node - the id of the node under consideration  in_quarantine - boolean flag that specify if the pearson is already qurantained and he/she shows simptoms   current_time - float the absolute time since the beginning of the simulation",
            "title": "enforce_policy"
        },
        {
            "location": "/DigitalContactTracing/#inizialize_contacts",
            "text": "inizialize_contacts(graph)  Initialize the contacts from the temporal graph.    The method creates a list where the element at position idx is \nthe list of contacts of the node idx. Each of these lists is initally empty.   INPUT      graph - networkx.classes.graph.Graph snapshots of the temporal graph",
            "title": "inizialize_contacts"
        },
        {
            "location": "/DigitalContactTracing/#inizialize_infected_time0",
            "text": "inizialize_infected_time0(graph)  Initialize the status of the initial infected people.   The method adds the people contained in self.Y_i_nodes to the list I, and defines their infectiousness properties.",
            "title": "inizialize_infected_time0"
        },
        {
            "location": "/DigitalContactTracing/#policy",
            "text": "policy(graph, node)  Implements a policy on a node in a graph.  The method gets the neighbors of the node, and for each neighbor it applies the policy to decide if it is 'at risk' or not.   INPUT      graph - networkx.classes.graph.Graph snapshots of the temporal graph  node - the id of the node under consideration",
            "title": "policy"
        },
        {
            "location": "/DigitalContactTracing/#simulate",
            "text": "simulate()  Run the simulation.  The method runs the simulation on the temporal network.  OUTPUT   eT: list  tracing effectivity, per time instant  sym_t: list  symptomatic people, full history  iso_t: list  isolated people, full history  act_inf_t: list infected people, full history  q_t: list number of quarantined, full history  q_t_i: list number of wrongly quarantined, full history  Q_nb: list number of distict elements in self.Q_list  Qi_nb: list number of distinct elements in self.Qi_list  I: dict details of infected people",
            "title": "simulate"
        },
        {
            "location": "/DigitalContactTracing/#update_contacts",
            "text": "update_contacts(current_time)  Update the list of quarantined people  INPUT      current_time - the absolute time since the beginning of the simulation",
            "title": "update_contacts"
        },
        {
            "location": "/DigitalContactTracing/#update_infected",
            "text": "update_infected( current_time, graph, new_infected)  Updates the state of the infected nodes.  The method updates the state of each infected node by advancing in time\nits information and by checking if it has become symptomatic.\nMoreover, an infected node may be isolated according to the isolation \nefficiency: If it is not isolated, it spread the infection to its \nneighbors; If it is isolated, the tracing policy is enforced on its \ncontacts.  INPUT      current_time - float the absolute time since the beginning of the simulation    graph - networkx.classes.graph.Graph snapshots of the temporal graph  new_infected - list of pearson newely infected",
            "title": "update_infected"
        },
        {
            "location": "/DigitalContactTracing/#check_quarantined",
            "text": "check_quarantined(current_time)  Check the status of quarantined nodes.  The method checks if a nodes becomes symptomatic while in quarantine, and in this case the tracing policy is enforced on its contacts.  INPUT      current_time - float the absolute time since the beginning of the simulation",
            "title": "check_quarantined"
        },
        {
            "location": "/DigitalContactTracing/#utilities",
            "text": "",
            "title": "UTILITIES"
        },
        {
            "location": "/DigitalContactTracing/#store_real_time",
            "text": "store_real_time(res,PARAMETERS,filter_rssi,filter_duration,eps_I)  Store the results of the simulation at the end of each single iteration.\nIf the file does not exists, it create the file, otherwise it append the current results to the file.  INPUT      res - list that contains the output of the simulation  PARAMETERS - dict containing all the parameters of the simulation (se the examples Digital-Contact-Tracing on SocioPattern.ipynb and Digital-Contact-Tracing on DTU.ipynb)  filter_rssi - float  wrongly RSSI threshold of the digital tracing policy   filter_duration - float  wrongly duration threshold of the digital tracing policy  eps_I - float wrongly  isolation effectivity",
            "title": "store_real_time"
        },
        {
            "location": "/DigitalContactTracing/#load_results",
            "text": "load_results(path,file,eps_I,filter_rssi,filter_duration)  Load stored results  INPUT      path - string representing the path in which results are stored  file - string specifing the file to load. One of the follow:  q_t   number of quarantined  q_t_i  number of wrongly quarantined  Q_list  list  of quarantined  Qi_lis  list of wrongly quarantined  I  dict  with details of infected people   sym_t  list of symptomatic people  iso_t  list of isolated people  act_inf_t  list of infected people    eps_I - float wrongly  isolation effectivity  filter_rssi - float  wrongly RSSI threshold of the digital tracing policy   filter_duration - float  wrongly duration threshold of the digital tracing policy   OUTPUT   An array containing the loaded results.",
            "title": "load_results"
        },
        {
            "location": "/functionsContinousModel/",
            "text": "Functions Continuous Model\n\n\nMidpointNormalize\n\n\nMidpointNormalize(colors.Normalize)\n\n\n\nNormalise the colorbar.\n\n\nThe function normalises a colorbar so that diverging bars work there way either side from a prescribed midpoint value),\ne.g. im=ax1.imshow(array, norm=MidpointNormalize(midpoint=0.,vmin=-100, vmax=100))\n\n\nSource :\nLink\n\n\ntime_evolution\n\n\ntime_evolution(tau, Lambda_0, T, epsilon=epsilon, s=s, beta=beta, age=age)\n\n\n\nSimulate the continuous model on a discrete time grid.\n\n\nThe function computes the time evolution of the number of infected people according to the dynamics defined by the continuous model, which is discretized on an equally-spaced time grid. \n\n\nINPUT\n  \n\n\n\n\ntau - np.array time grid\n\n\nLambda_0 - np.array initial number of infected people, with varying infection age\n\n\nT - float simulation time\n\n\nepsilon - function that returns a (possibly time-dependend) pair (eps_I, eps_T)\n\n\nbeta - function time-dependent infectiousness\n\n\nage - float maximal time since infection of the initially infected people\n\n\n\n\nOUTPUT\n\n\n\n\nnp.sum(Lambda, axis=1)[age:] - cumulative distribution of the infected people\n\n\nLambda - time distribution of the infected people \n\n\nA - system evolution matrix",
            "title": "functionsContinousModel"
        },
        {
            "location": "/functionsContinousModel/#functions-continuous-model",
            "text": "",
            "title": "Functions Continuous Model"
        },
        {
            "location": "/functionsContinousModel/#midpointnormalize",
            "text": "MidpointNormalize(colors.Normalize)  Normalise the colorbar.  The function normalises a colorbar so that diverging bars work there way either side from a prescribed midpoint value),\ne.g. im=ax1.imshow(array, norm=MidpointNormalize(midpoint=0.,vmin=-100, vmax=100))  Source : Link",
            "title": "MidpointNormalize"
        },
        {
            "location": "/functionsContinousModel/#time_evolution",
            "text": "time_evolution(tau, Lambda_0, T, epsilon=epsilon, s=s, beta=beta, age=age)  Simulate the continuous model on a discrete time grid.  The function computes the time evolution of the number of infected people according to the dynamics defined by the continuous model, which is discretized on an equally-spaced time grid.   INPUT      tau - np.array time grid  Lambda_0 - np.array initial number of infected people, with varying infection age  T - float simulation time  epsilon - function that returns a (possibly time-dependend) pair (eps_I, eps_T)  beta - function time-dependent infectiousness  age - float maximal time since infection of the initially infected people   OUTPUT   np.sum(Lambda, axis=1)[age:] - cumulative distribution of the infected people  Lambda - time distribution of the infected people   A - system evolution matrix",
            "title": "time_evolution"
        },
        {
            "location": "/loadTemporalGraph/",
            "text": "load_df\n\n\nload_df(file_name, n_individuals=None, n_row=None, seed=None)\n\n\n\nLoad a dataset into a dataframe.\n\n\nThe function reads a dataset representing pairwise interactions between \nindividuals. \nIf required, the function may crop the dataset by keeping only \na max number of interactions or a max number of randomly chosen individuals. \n\n\nINPUT\n  \n\n\n\n\nfile_name: str - file to be loaded\n\n\nn_individuals: int - max number of individuals to keep, or None to load all the individuals\n\n\nn_row: int - max number of interactions to keep, or None to load all the interactions\n\n\nseed: float - random seed to shuffle the individuals when selecting a subset, or None\n\n\n\n\nOUTPUTS\n \n\n\n\n\ndf: pandas dataframe - dataset        \n\n\n\n\nremove_individuals\n\n\nremove_individuals(df, n_individuals)\n\n\n\nRestrict a dataset to a subset of the individuals.\n\n\nThe function crops the dataset df by keeping only the interactions \ninvolving a set of n_individuals, which are randomly chosen. \n\n\nINPUT\n  \n\n\n\n\ndf: pandas dataframe - dataset \n\n\nn_individuals: int - max number of individuals to keep\n\n\n\n\nOUTPUTS\n \n\n\n\n\ndf: pandas dataframe - dataset\n\n\n\n\nget_array_of_contacts\n\n\nget_array_of_contacts(df, temporal_gap, column_name)\n\n\n\nGroup a temporal dataset into discrete times.\n\n\nThe function groups the contacts stored in df into sets corresponding to\ncontacts happening at the same time window. The time windows are computed\nbased on temporal-gap.\n\n\nINPUT\n  \n\n\n\n\ndf: pandas dataframe - dataset \n\n\ntemporal_gap: float - timestep between consecutive snapshopt of the temporal dataset\n\n\n\n\nOUTPUTS\n \n\n\n\n\nstatic_contacts: list - groups of simultaneous contacts  \n\n\n\n\nget_individuals\n\n\nget_individuals(df)\n\n\n\nGet the individuals who are present in the dataset.\n\n\nThe function return a list of all the unique individuals who are present in\nthe dataset.\n\n\nINPUT\n  \n\n\n\n\ndf: pandas dataframe - dataset \n\n\n\n\nOUTPUTS\n \n\n\n\n\nnodes_list: list - individuals in the dataset \n\n\n\n\nbuild_graphs\n\n\nbuild_graphs(static_contacts, temporal_gap)\n\n\n\nGet the individuals who are present in the dataset.\n\n\nThe function returns a list of graphs, in wich each graph represent \ninteractions between nodes.\nEach edge has two attributes (rssi and duration), where rssi is the power \nof the bluethoot signal and duration is the cumulative duration of the \ncontact between two individuals.\nIf two users keep interacting for multiple temporal instants, then the rssi\nsignal is averaged.\n\n\nINPUT\n  \n\n\n\n\nstatic_contacts: list -  groups of simultaneous contacts \n\n\ntemporal_gap: float - timestep between consecutive snapshopt of the temporal dataset\n\n\n\n\nOUTPUTS\n \n\n\n\n\ngraphs: list of Networkx graphs - graphs representing the interactions at each temporal instant \n\n\n\n\nload_df_socio\n\n\n#load_df_socio(file_name, extend=True, n_row=None, seed=None)\n\n\n\nLoad a sociopattern dataset into a dataframe.\n\n\nThe function reads a dataset representing pairwise interactions between \nindividuals. \nIf required, the function may crop the dataset by keeping only \na max number of interactions.\nMoreover, the function can extend the dataset in time by appending three\ncopies of the dataset one after the other.\n\n\nINPUT\n  \n\n\n\n\nfile_name: str - file to be loaded\n\n\nextend: bool - decide if the multiple copies of the datasets are appended in time n_row: int\n\n\nn_row: int - max number of interactions to keep, or None to load all the interactions\n\n\nseed: float - random seed to shuffle the individuals when selecting a subset, or None\n\n\n\n\nOUTPUTS\n \n\n\n\n\ndf: pandas dataframe - dataset        \n\n\n\n\nbuild_graphs_socio\n\n\n#build_graphs_socio(static_contacts, temporal_gap)\n\n\n\nGet the graphs representing the interactions at each temporal instant\n\n\nThe function returns a list of graphs, in wich each graph represent \ninteractions between nodes.\nEach edge has an attribute duration which is the cumulative duration of the \ncontact between two individuals.\n\n\nINPUT\n  \n\n\n\n\nstatic_contacts: list - groups of simultaneous contacts \n\n\ntemporal_gap: float - timestep between consecutive snapshopt of the temporal dataset\n\n\n\n\nOUTPUTS\n \n\n\n\n\ngraphs: list of Networkx graphs - graphs representing the interactions at each temporal instant                \n\n\n\n\nshow_animation\n\n\n#show_animation(graphs, save=False)\n\n\n\nShow an animation of the time evolution of the contact network.\n\n\nThe function shows returns an animation of the time evolution of a temporal\nnetwork.\n\n\nINPUT\n  \n\n\n\n\ngraphs: list of Networkx graphs - graphs representing the interactions at each temporal instant                \n\n\nsave: bool - return or not an animation object (that can be saved)\n\n\n\n\nOUTPUTS\n \n\n\n\n\nani: matplotlib.animation  - animation object                 \n\n\n\n\ncompute_comulative\n\n\n#compute_comulative(graphs)\n\n\n\nComputes the static aggregation of a temporal network.\n\n\nThe function computes a static graph obtained by merging all the snaphots \nof a temporal network.\n\n\nINPUT\n  \n\n\n\n\ngraphs: list of Networkx graphs - graphs representing the interactions at each temporal instant                \n\n\nsave: bool - return or not an animation object (that can be saved)\n\n\n\n\nOUTPUTS\n \n\n\n\n\ncumulative_graphs: Networkx graph  - cumulative static graph",
            "title": "loadTemporalGraph"
        },
        {
            "location": "/loadTemporalGraph/#load_df",
            "text": "load_df(file_name, n_individuals=None, n_row=None, seed=None)  Load a dataset into a dataframe.  The function reads a dataset representing pairwise interactions between \nindividuals. \nIf required, the function may crop the dataset by keeping only \na max number of interactions or a max number of randomly chosen individuals.   INPUT      file_name: str - file to be loaded  n_individuals: int - max number of individuals to keep, or None to load all the individuals  n_row: int - max number of interactions to keep, or None to load all the interactions  seed: float - random seed to shuffle the individuals when selecting a subset, or None   OUTPUTS     df: pandas dataframe - dataset",
            "title": "load_df"
        },
        {
            "location": "/loadTemporalGraph/#remove_individuals",
            "text": "remove_individuals(df, n_individuals)  Restrict a dataset to a subset of the individuals.  The function crops the dataset df by keeping only the interactions \ninvolving a set of n_individuals, which are randomly chosen.   INPUT      df: pandas dataframe - dataset   n_individuals: int - max number of individuals to keep   OUTPUTS     df: pandas dataframe - dataset",
            "title": "remove_individuals"
        },
        {
            "location": "/loadTemporalGraph/#get_array_of_contacts",
            "text": "get_array_of_contacts(df, temporal_gap, column_name)  Group a temporal dataset into discrete times.  The function groups the contacts stored in df into sets corresponding to\ncontacts happening at the same time window. The time windows are computed\nbased on temporal-gap.  INPUT      df: pandas dataframe - dataset   temporal_gap: float - timestep between consecutive snapshopt of the temporal dataset   OUTPUTS     static_contacts: list - groups of simultaneous contacts",
            "title": "get_array_of_contacts"
        },
        {
            "location": "/loadTemporalGraph/#get_individuals",
            "text": "get_individuals(df)  Get the individuals who are present in the dataset.  The function return a list of all the unique individuals who are present in\nthe dataset.  INPUT      df: pandas dataframe - dataset    OUTPUTS     nodes_list: list - individuals in the dataset",
            "title": "get_individuals"
        },
        {
            "location": "/loadTemporalGraph/#build_graphs",
            "text": "build_graphs(static_contacts, temporal_gap)  Get the individuals who are present in the dataset.  The function returns a list of graphs, in wich each graph represent \ninteractions between nodes.\nEach edge has two attributes (rssi and duration), where rssi is the power \nof the bluethoot signal and duration is the cumulative duration of the \ncontact between two individuals.\nIf two users keep interacting for multiple temporal instants, then the rssi\nsignal is averaged.  INPUT      static_contacts: list -  groups of simultaneous contacts   temporal_gap: float - timestep between consecutive snapshopt of the temporal dataset   OUTPUTS     graphs: list of Networkx graphs - graphs representing the interactions at each temporal instant",
            "title": "build_graphs"
        },
        {
            "location": "/loadTemporalGraph/#load_df_socio",
            "text": "#load_df_socio(file_name, extend=True, n_row=None, seed=None)  Load a sociopattern dataset into a dataframe.  The function reads a dataset representing pairwise interactions between \nindividuals. \nIf required, the function may crop the dataset by keeping only \na max number of interactions.\nMoreover, the function can extend the dataset in time by appending three\ncopies of the dataset one after the other.  INPUT      file_name: str - file to be loaded  extend: bool - decide if the multiple copies of the datasets are appended in time n_row: int  n_row: int - max number of interactions to keep, or None to load all the interactions  seed: float - random seed to shuffle the individuals when selecting a subset, or None   OUTPUTS     df: pandas dataframe - dataset",
            "title": "load_df_socio"
        },
        {
            "location": "/loadTemporalGraph/#build_graphs_socio",
            "text": "#build_graphs_socio(static_contacts, temporal_gap)  Get the graphs representing the interactions at each temporal instant  The function returns a list of graphs, in wich each graph represent \ninteractions between nodes.\nEach edge has an attribute duration which is the cumulative duration of the \ncontact between two individuals.  INPUT      static_contacts: list - groups of simultaneous contacts   temporal_gap: float - timestep between consecutive snapshopt of the temporal dataset   OUTPUTS     graphs: list of Networkx graphs - graphs representing the interactions at each temporal instant",
            "title": "build_graphs_socio"
        },
        {
            "location": "/loadTemporalGraph/#show_animation",
            "text": "#show_animation(graphs, save=False)  Show an animation of the time evolution of the contact network.  The function shows returns an animation of the time evolution of a temporal\nnetwork.  INPUT      graphs: list of Networkx graphs - graphs representing the interactions at each temporal instant                  save: bool - return or not an animation object (that can be saved)   OUTPUTS     ani: matplotlib.animation  - animation object",
            "title": "show_animation"
        },
        {
            "location": "/loadTemporalGraph/#compute_comulative",
            "text": "#compute_comulative(graphs)  Computes the static aggregation of a temporal network.  The function computes a static graph obtained by merging all the snaphots \nof a temporal network.  INPUT      graphs: list of Networkx graphs - graphs representing the interactions at each temporal instant                  save: bool - return or not an animation object (that can be saved)   OUTPUTS     cumulative_graphs: Networkx graph  - cumulative static graph",
            "title": "compute_comulative"
        },
        {
            "location": "/systemDefinition/",
            "text": "omega\n\n\nomega(tau)\n\n\n\nInfectiousness probability at time tau.\n\n\nThis functions defines the infection probability as a function of the time elapsed since infection. The distribution is a Weibull distribution with the given shape and scale\n\n\nINPUT\n  \n\n\n\n\ntau: np.array - time since infection\n\n\n\n\nOUTPUTS\n \n\n\n\n\np: pandas dataframe - infectiousness probability        \n\n\n\n\nbeta\n\n\nbeta(tau)\n\n\n\nInfectiousness at time tau, used by the continuous model. \n\n\nThis functions defines the infectiousness as a function of the time\nelapsed since infection. The result is a the value of the infectioun probability, scaled by R0.    \n\n\nINPUT\n  \n\n\n\n\ntau: np.array -  time since infection \n\n\n\n\nOUTPUTS\n \n\n\n\n\ninf: np.array  - infectiousness\n\n\n\n\nbeta_exposure\n\n\nbeta_exposure(e, beta_t=0.002)\n\n\n\nInfectiousness as a function of the contact duration. \n\n\nThis functions defines component of the infectiousness that is a function of the duration of a contact in the network. \n\n\nINPUT\n  \n\n\n\n\ne: float - contact duration in seconds\n\n\nbeta_t: float DEFAULT = 0.002 -  istantaneous infection robability (i.e. per unit time)\n\n\n\n\nOUTPUTS\n \n\n\n\n\nval: float  - infectiousness\n\n\n\n\nbeta_dist_sign\n\n\nbeta_dist_sign(ss)\n\n\n\nInfectiousness as a function of the signal strength. \n\n\nThis functions defines component of the infectiousness that is a function of the signal strenght (roughly: distance) of a contact in the network. \n\n\nINPUT\n  \n\n\n\n\nss: float - signal strenght \n\n\n\n\nOUTPUTS\n \n\n\n\n\nval: float  - infectiousness\n\n\n\n\nbeta_data\n\n\nbeta_data(tau, ss, e, beta_t, omega=omega, beta_exposure=beta_exposure, beta_dist_sign=beta_dist_sign)\n\n\n\nInfectiousness at time tau, used by the network simulation. \n\n\nThis functions defines the infectiousness as a function of the time elapsed since infection, on the distance of a contact, and on the signal strength (if not None) of a contact. \n\n\nINPUT\n  \n\n\n\n\ntau: np.array - time since infection\n\n\nss: float - signal strenght \n\n\ne: float - contact duration in seconds\n\n\nbeta_t: float DEFAULT = 0.002 -  istantaneous infection robability (i.e. per unit time)\n\n\nomega: function -  probability at time tau\n\n\nbeta_exposure: function - infectiousness as a function of the contact duration. \n\n\nbeta_dist: function - infectiousness as a function of the signal strength\n\n\n\n\nOUTPUTS\n \n\n\n\n\nval: float  - infectiousness\n\n\n\n\nconvert_dist_to_s\n\n\nconvert_dist_to_s(dist)\n\n\n\nConvert a distance to a signal strenght. \n\n\nThe function converts a distance to a signal strenght. \n\n\nINPUT\n  \n\n\n\n\ndist: float - distance \n\n\n\n\nOUTPUTS\n \n\n\n\n\nval: float  - signal strength\n\n\n\n\nconvert_s_to_dist\n\n\nconvert_s_to_dist(x)\n\n\n\nConvert a signal strenght to a distance. \n\n\nThe function converts a signal strength to a distance. The conversion is not accurate, and it is only use for the definition of beta_dist. \n\n\nINPUT\n  \n\n\n\n\nx: float - signal strength \n\n\n\n\nOUTPUTS\n \n\n\n\n\nval: float  - distance\n\n\n\n\nonset_time\n\n\nonset_time(mean=MEAN, std=STD, symptomatics=SYMPTOMATICS, testing=TESTING, delay=DELAY)\n\n\n\nSample from the probability distribution of the symptoms onset.\n\n\nThis functions returns a time (days) which is a sample from the \ndistribution that describes the probability for an infected individual to be detected at a certain time, either because it becomes symptomatic, or because it is randomly tested.\n\n\nThe distribution is a lognormal with delayed mean, scaled to \n[0, symptomatics], and then lifted up by relative_testing (the sample is converted to seconds).\n\n\nINPUT\n  \n\n\n\n\nmean: float - mean onset time \n\n\nstd: float - std onset time\n\n\nsymptomatics: float DEFAULT = 0.8  - fraction of symptomatic people \n\n\ntesting: float DEFAULT = 0.25  - fraction of testing of asymptomatics \n\n\ndelay: float DEFAULT = 2 -  delay in the reporting (in days)\n\n\n\n\nOUTPUTS\n \n\n\n\n\ns_tau: float  - probability to be detected before time tau\n\n\n\n\nepsilon\n\n\nepsilon(tau)\n\n\n\nInfectiousness at time tau. \n\n\nThis functions defines the infectiousness as a function of the time\nelapsed since infection. The result is a the value of the infectioun probability, scaled by R0.    \n\n\nINPUT\n  \n\n\n\n\ntau: np.array - time since infection \n\n\n\n\nOUTPUTS\n \n\n\n\n\neps_I: np.array  - isolation efficiency\n\n\neps_T: np.array  - tracing efficiency",
            "title": "systemDefinition"
        },
        {
            "location": "/systemDefinition/#omega",
            "text": "omega(tau)  Infectiousness probability at time tau.  This functions defines the infection probability as a function of the time elapsed since infection. The distribution is a Weibull distribution with the given shape and scale  INPUT      tau: np.array - time since infection   OUTPUTS     p: pandas dataframe - infectiousness probability",
            "title": "omega"
        },
        {
            "location": "/systemDefinition/#beta",
            "text": "beta(tau)  Infectiousness at time tau, used by the continuous model.   This functions defines the infectiousness as a function of the time\nelapsed since infection. The result is a the value of the infectioun probability, scaled by R0.      INPUT      tau: np.array -  time since infection    OUTPUTS     inf: np.array  - infectiousness",
            "title": "beta"
        },
        {
            "location": "/systemDefinition/#beta_exposure",
            "text": "beta_exposure(e, beta_t=0.002)  Infectiousness as a function of the contact duration.   This functions defines component of the infectiousness that is a function of the duration of a contact in the network.   INPUT      e: float - contact duration in seconds  beta_t: float DEFAULT = 0.002 -  istantaneous infection robability (i.e. per unit time)   OUTPUTS     val: float  - infectiousness",
            "title": "beta_exposure"
        },
        {
            "location": "/systemDefinition/#beta_dist_sign",
            "text": "beta_dist_sign(ss)  Infectiousness as a function of the signal strength.   This functions defines component of the infectiousness that is a function of the signal strenght (roughly: distance) of a contact in the network.   INPUT      ss: float - signal strenght    OUTPUTS     val: float  - infectiousness",
            "title": "beta_dist_sign"
        },
        {
            "location": "/systemDefinition/#beta_data",
            "text": "beta_data(tau, ss, e, beta_t, omega=omega, beta_exposure=beta_exposure, beta_dist_sign=beta_dist_sign)  Infectiousness at time tau, used by the network simulation.   This functions defines the infectiousness as a function of the time elapsed since infection, on the distance of a contact, and on the signal strength (if not None) of a contact.   INPUT      tau: np.array - time since infection  ss: float - signal strenght   e: float - contact duration in seconds  beta_t: float DEFAULT = 0.002 -  istantaneous infection robability (i.e. per unit time)  omega: function -  probability at time tau  beta_exposure: function - infectiousness as a function of the contact duration.   beta_dist: function - infectiousness as a function of the signal strength   OUTPUTS     val: float  - infectiousness",
            "title": "beta_data"
        },
        {
            "location": "/systemDefinition/#convert_dist_to_s",
            "text": "convert_dist_to_s(dist)  Convert a distance to a signal strenght.   The function converts a distance to a signal strenght.   INPUT      dist: float - distance    OUTPUTS     val: float  - signal strength",
            "title": "convert_dist_to_s"
        },
        {
            "location": "/systemDefinition/#convert_s_to_dist",
            "text": "convert_s_to_dist(x)  Convert a signal strenght to a distance.   The function converts a signal strength to a distance. The conversion is not accurate, and it is only use for the definition of beta_dist.   INPUT      x: float - signal strength    OUTPUTS     val: float  - distance",
            "title": "convert_s_to_dist"
        },
        {
            "location": "/systemDefinition/#onset_time",
            "text": "onset_time(mean=MEAN, std=STD, symptomatics=SYMPTOMATICS, testing=TESTING, delay=DELAY)  Sample from the probability distribution of the symptoms onset.  This functions returns a time (days) which is a sample from the \ndistribution that describes the probability for an infected individual to be detected at a certain time, either because it becomes symptomatic, or because it is randomly tested.  The distribution is a lognormal with delayed mean, scaled to \n[0, symptomatics], and then lifted up by relative_testing (the sample is converted to seconds).  INPUT      mean: float - mean onset time   std: float - std onset time  symptomatics: float DEFAULT = 0.8  - fraction of symptomatic people   testing: float DEFAULT = 0.25  - fraction of testing of asymptomatics   delay: float DEFAULT = 2 -  delay in the reporting (in days)   OUTPUTS     s_tau: float  - probability to be detected before time tau",
            "title": "onset_time"
        },
        {
            "location": "/systemDefinition/#epsilon",
            "text": "epsilon(tau)  Infectiousness at time tau.   This functions defines the infectiousness as a function of the time\nelapsed since infection. The result is a the value of the infectioun probability, scaled by R0.      INPUT      tau: np.array - time since infection    OUTPUTS     eps_I: np.array  - isolation efficiency  eps_T: np.array  - tracing efficiency",
            "title": "epsilon"
        }
    ]
}